#!/usr/bin/env python

"""
Script to prepare JSON output for tidal sync servers from the list of hosts
"""

from __future__ import division
from __future__ import print_function

import json
import sys

from collections import defaultdict, namedtuple

from ansible.executor.task_queue_manager import TaskQueueManager
from ansible.module_utils.common.collections import ImmutableDict
from ansible.inventory.manager import InventoryManager
from ansible.parsing.dataloader import DataLoader
from ansible.playbook.play import Play
from ansible.plugins.callback import CallbackBase
from ansible.vars.manager import VariableManager
from ansible import context

TOTAL_RESULTS = {'servers': [], 'errors': []}

def eprint(*args, **kwargs):
    """Print to stderr"""
    print(*args, file=sys.stderr, **kwargs)

def ram_allocated_gb(facts):
    """Return total memory allocation in GB"""
    return facts['ansible_memtotal_mb'] / 1024

def ram_used_gb(facts):
    """Return used memory in GB"""
    return (facts['ansible_memtotal_mb'] - facts['ansible_memfree_mb']) / 1024

def _size(key, mounts):
    return sum([item.get(key, 0) for item in mounts])

def storage_allocated_gb(facts):
    """Return total storage allocation in GB"""
    if 'ansible_mounts' not in facts:
        return 0
    return _size('size_total', facts['ansible_mounts']) / 1024**3

def storage_used_gb(facts):
    """Return used storage in GB"""
    if 'ansible_mounts' not in facts:
        return 0
    return (_size('size_total', facts['ansible_mounts']) -
            _size('size_available', facts['ansible_mounts'])) / 1024**3

def cpu_count(facts):
    """Return the number of CPUs"""
    return max([
        int(facts.get('ansible_processor_count', 0)),
        int(facts.get('ansible_processor_vcpus', 0))
    ])

def cpu_name(proc):
    """Return CPU name"""
    items_count = len(proc)
    if items_count == 1:
        return proc[0]
    if items_count >= 3:
        return proc[2]
    return 'Unknown'

class ResultCallback(CallbackBase):
    """A sample callback plugin used for performing an action as results come in
    
    If you want to collect all results into a single object for processing at
    the end of the execution, look into utilizing the ``json`` callback plugin
    or writing your own custom callback plugin.
    """

    def __init__(self, *args, **kwargs):
        super(ResultCallback, self).__init__(*args, **kwargs)
        self.host_ok = {}
        self.host_unreachable = {}
        self.host_failed = {}
        self.host_no_mounts = {}

    def v2_runner_on_unreachable(self, result):
        host = result._host
        self.host_unreachable[host.get_name()] = result
        eprint('{0} >>> {1}'.format(host.get_name(), result._result['msg']))

        TOTAL_RESULTS['errors'].append({
            'host': host.get_name(),
            'msg': result._result['msg']
        })   

    def v2_runner_on_failed(self, result, *args, **kwargs):
        host = result._host
        self.host_failed[host.get_name()] = result
        eprint('{0} >>> {1}'.format(host.get_name(), result._result['msg']))

        TOTAL_RESULTS['errors'].append({
            'host': host.get_name(),
            'msg': result._result['msg']
        })   

    def v2_runner_on_ok(self, result):
        facts = result._result['ansible_facts']
        host = result._host

        if 'ansible_mounts' not in facts:
            self.host_no_mounts[host.get_name()] = result
            eprint('{0}: no ansible_mounts in facts'.format(host))
            TOTAL_RESULTS['errors'].append({
                'host': host.get_name(),
                'msg': 'no ansible_mounts in facts'
            })

        self.host_ok[host.get_name()] = result

        TOTAL_RESULTS['servers'].append({
            'host_name': facts['ansible_hostname'],
            'fqdn': facts['ansible_fqdn'],
            'ip_addresses': facts['ansible_all_ipv4_addresses'] + facts['ansible_all_ipv6_addresses'],
            'ram_allocated_gb': ram_allocated_gb(facts),
            'ram_used_gb': ram_used_gb(facts),
            'storage_allocated_gb': storage_allocated_gb(facts),
            'storage_used_gb': storage_used_gb(facts),
            'cpu_count': cpu_count(facts),
            'operating_system': facts['ansible_distribution'],
            'operating_system_version': facts['ansible_distribution_version'],
            'cpu_name': cpu_name(facts['ansible_processor'])
        })

def main():
    # Since the API is constructed for CLI it expects certain options to always be set in the context object
    context.CLIARGS = ImmutableDict(connection='smart', module_path=['/to/mymodules', '/usr/share/ansible'], forks=10, become=None,
                                    become_method=None, become_user=None, check=False, diff=False, verbosity=0)
    LOADER = DataLoader()
    PASSWORDS = dict(vault_pass='secret')
    RESULTS_CALLBACK = ResultCallback()
    INVENTORY = InventoryManager(loader=LOADER, sources='hosts')
    VARIABLE_MANAGER = VariableManager(loader=LOADER, inventory=INVENTORY)
    PLAY_SOURCE = dict(
        name='Ansible Play',
        hosts='all',
        gather_facts='yes'
    )
    PLAY = Play().load(PLAY_SOURCE, variable_manager=VARIABLE_MANAGER,
                       loader=LOADER)
    TQM = None
    try:
        TQM = TaskQueueManager(
            inventory=INVENTORY,
            variable_manager=VARIABLE_MANAGER,
            loader=LOADER,
            passwords=PASSWORDS,
            stdout_callback=RESULTS_CALLBACK
        )
        TQM.run(PLAY)
        print(json.dumps(TOTAL_RESULTS, indent=4))
    finally:

        results_callback = RESULTS_CALLBACK
        eprint("UP *********************************")
        for host, result in results_callback.host_ok.items():
            eprint('{0}'.format(host))

        eprint("FAILED *****************************")
        for host, result in results_callback.host_failed.items():
            eprint('{0} >>> {1}'.format(host, result._result['msg']))

        eprint("DOWN *******************************")
        for host, result in results_callback.host_unreachable.items():
            eprint('{0} >>> {1}'.format(host, result._result['msg']))

        eprint("NO ANSIBLE_MOUNTS IN FACTS *********")
        for host, result in results_callback.host_no_mounts.items():
            eprint('{0}'.format(host))

        if TQM is not None:
            TQM.cleanup()


if __name__ == '__main__':
    main()
