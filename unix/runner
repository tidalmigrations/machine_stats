#!/usr/bin/env python

"""
Script to prepare JSON output for tidal sync servers from the list of hosts
"""

from __future__ import division

import json

from collections import defaultdict, namedtuple

from ansible.executor.task_queue_manager import TaskQueueManager
from ansible.inventory.manager import InventoryManager
from ansible.parsing.dataloader import DataLoader
from ansible.playbook.play import Play
from ansible.plugins.callback import CallbackBase
from ansible.vars.manager import VariableManager

TOTAL_RESULTS = {'servers': []}

def ram_allocated_gb(facts):
    """Return total memory allocation in GB"""
    return facts['ansible_memtotal_mb'] / 1024

def ram_used_gb(facts):
    """Return used memory in GB"""
    return (facts['ansible_memtotal_mb'] - facts['ansible_memfree_mb']) / 1024

def _size(key, mounts):
    return sum([item.get(key, 0) for item in mounts])

def storage_allocated_gb(facts):
    """Return total storage allocation in GB"""
    return _size('size_total', facts['ansible_mounts']) / 1024**3

def storage_used_gb(facts):
    """Return used storage in GB"""
    return (_size('size_total', facts['ansible_mounts']) -
            _size('size_available', facts['ansible_mounts'])) / 1024**3

def cpu_count(facts):
    """Return the number of CPUs"""
    return max([
        int(facts.get('ansible_processor_count', 0)),
        int(facts.get('ansible_processor_vcpus', 0))
    ])

def cpu_name(proc):
    """Return CPU name"""
    items_count = len(proc)
    if items_count == 1:
        return proc[0]
    if items_count >= 3:
        return proc[2]
    return 'Unknown'

class ResultCallback(CallbackBase):
    """A sample callback plugin used for performing an action as results come
    in"""
    def v2_runner_on_ok(self, result):
        facts = result._result['ansible_facts']

        TOTAL_RESULTS['servers'].append({
            'host_name': facts['ansible_hostname'],
            'fqdn': facts['ansible_fqdn'],
            'ip_addresses': facts['ansible_all_ipv4_addresses'] + facts['ansible_all_ipv6_addresses'],
            'ram_allocated_gb': ram_allocated_gb(facts),
            'ram_used_gb': ram_used_gb(facts),
            'storage_allocated_gb': storage_allocated_gb(facts),
            'storage_used_gb': storage_used_gb(facts),
            'cpu_count': cpu_count(facts),
            'operating_system': facts['ansible_distribution'],
            'operating_system_version': facts['ansible_distribution_version'],
            'cpu_name': cpu_name(facts['ansible_processor'])
        })

Options = namedtuple('Options', ['connection', 'module_path', 'forks',
                                 'become', 'become_method', 'become_user',
                                 'check', 'diff'])
OPTIONS = Options(connection='smart', module_path=['/to/mymodules'], forks=10,
                  become=None, become_method=None, become_user=None,
                  check=False, diff=False)

LOADER = DataLoader()
PASSWORDS = dict(vault_pass='secret')
RESULTS_CALLBACK = ResultCallback()
INVENTORY = InventoryManager(loader=LOADER, sources='hosts')
VARIABLE_MANAGER = VariableManager(loader=LOADER, inventory=INVENTORY)
PLAY_SOURCE = dict(
    name='Ansible Play',
    hosts='all',
    gather_facts='yes'
)
PLAY = Play().load(PLAY_SOURCE, variable_manager=VARIABLE_MANAGER,
                   loader=LOADER)
TQM = None
try:
    TQM = TaskQueueManager(
        inventory=INVENTORY,
        variable_manager=VARIABLE_MANAGER,
        loader=LOADER,
        options=OPTIONS,
        passwords=PASSWORDS,
        stdout_callback=RESULTS_CALLBACK
    )
    TQM.run(PLAY)
    print json.dumps(TOTAL_RESULTS, indent=4)
finally:
    if TQM is not None:
        TQM.cleanup()
