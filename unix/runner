#!/usr/bin/env python

"""
Script to prepare JSON output for tidal sync servers from the list of hosts
"""

from __future__ import division
from __future__ import print_function

import json
import sys

from collections import defaultdict, namedtuple

from ansible.executor.task_queue_manager import TaskQueueManager
from ansible.inventory.manager import InventoryManager
from ansible.parsing.dataloader import DataLoader
from ansible.playbook.play import Play
from ansible.plugins.callback import CallbackBase
from ansible.vars.manager import VariableManager

TOTAL_RESULTS = {'servers': []}

def eprint(*args, **kwargs):
    """Print to stderr"""
    print(*args, file=sys.stderr, **kwargs)

def ram_allocated_gb(facts):
    """Return total memory allocation in GB"""
    return facts['ansible_memtotal_mb'] / 1024

def ram_used_gb(facts):
    """Return used memory in GB"""
    return (facts['ansible_memtotal_mb'] - facts['ansible_memfree_mb']) / 1024

def _size(key, mounts):
    return sum([item.get(key, 0) for item in mounts])

def storage_allocated_gb(facts):
    """Return total storage allocation in GB"""
    if 'ansible_mounts' not in facts:
        return 0
    return _size('size_total', facts['ansible_mounts']) / 1024**3

def storage_used_gb(facts):
    """Return used storage in GB"""
    if 'ansible_mounts' not in facts:
        return 0
    return (_size('size_total', facts['ansible_mounts']) -
            _size('size_available', facts['ansible_mounts'])) / 1024**3

def cpu_count(facts):
    """Return the number of CPUs"""
    return max([
        int(facts.get('ansible_processor_count', 0)),
        int(facts.get('ansible_processor_vcpus', 0))
    ])

def cpu_name(proc):
    """Return CPU name"""
    items_count = len(proc)
    if items_count == 1:
        return proc[0]
    if items_count >= 3:
        return proc[2]
    return 'Unknown'

class ResultCallback(CallbackBase):
    """A sample callback plugin used for performing an action as results come in
    
    If you want to collect all results into a single object for processing at
    the end of the execution, look into utilizing the ``json`` callback plugin
    or writing your own custom callback plugin.
    """

    def __init__(self, *args, **kwargs):
        super(ResultCallback, self).__init__(*args, **kwargs)
        self.host_ok = {}
        self.host_unreachable = {}
        self.host_failed = {}

    def v2_runner_on_unreachable(self, result):
        host = result._host
        self.host_unreachable[host.get_name()] = result

    def v2_runner_on_failed(self, result, *args, **kwargs):
        host = result._host
        self.host_failed[host.get_name()] = result

    def v2_runner_on_ok(self, result):
        host = result._host
        self.host_ok[host.get_name()] = result
        facts = result._result['ansible_facts']
        TOTAL_RESULTS['servers'].append({
            'host_name': facts['ansible_hostname'],
            'fqdn': facts['ansible_fqdn'],
            'ip_addresses': facts['ansible_all_ipv4_addresses'] + facts['ansible_all_ipv6_addresses'],
            'ram_allocated_gb': ram_allocated_gb(facts),
            'ram_used_gb': ram_used_gb(facts),
            'storage_allocated_gb': storage_allocated_gb(facts),
            'storage_used_gb': storage_used_gb(facts),
            'cpu_count': cpu_count(facts),
            'operating_system': facts['ansible_distribution'],
            'operating_system_version': facts['ansible_distribution_version'],
            'cpu_name': cpu_name(facts['ansible_processor'])
        })

Options = namedtuple('Options', ['connection', 'module_path', 'forks',
                                 'become', 'become_method', 'become_user',
                                 'check', 'diff'])
OPTIONS = Options(connection='smart', module_path=['/to/mymodules'], forks=10,
                  become=None, become_method=None, become_user=None,
                  check=False, diff=False)

LOADER = DataLoader()
PASSWORDS = dict(vault_pass='secret')
RESULTS_CALLBACK = ResultCallback()
INVENTORY = InventoryManager(loader=LOADER, sources='hosts')
VARIABLE_MANAGER = VariableManager(loader=LOADER, inventory=INVENTORY)
PLAY_SOURCE = dict(
    name='Ansible Play',
    hosts='all',
    gather_facts='yes'
)
PLAY = Play().load(PLAY_SOURCE, variable_manager=VARIABLE_MANAGER,
                   loader=LOADER)
TQM = None
try:
    TQM = TaskQueueManager(
        inventory=INVENTORY,
        variable_manager=VARIABLE_MANAGER,
        loader=LOADER,
        options=OPTIONS,
        passwords=PASSWORDS,
        stdout_callback=RESULTS_CALLBACK
    )
    TQM.run(PLAY)
    print(json.dumps(TOTAL_RESULTS, indent=4))
finally:

    results_callback = RESULTS_CALLBACK
    eprint("UP ***********")
    for host, result in results_callback.host_ok.items():
        eprint('{0}'.format(host))

    eprint("FAILED *******")
    for host, result in results_callback.host_failed.items():
        eprint('{0} >>> {1}'.format(host, result._result['msg']))
        # print('{0} >>> {1}'.format(host, result._result)) # use this to deep dive errors

    eprint("DOWN *********")
    for host, result in results_callback.host_unreachable.items():
        eprint('{0} >>> {1}'.format(host, result._result['msg']))

    if TQM is not None:
        TQM.cleanup()
